1. python 垃圾处理机制（内存优化）
> 在 Python 中，主要通过引用计数进行垃圾回收；通过 “标记-清除” 解决容器对象可能产生的循环
引用问题；通过 “分代回收” 以空间换时间的方法提高垃圾回收效率。也就是说，python 采用的是引
用计数机制为主，标记-清除和分代收集（隔代回收）两种机制为辅的策略。

> 引用计数：再python中，每个对象都有一个PyObject，其中的ob_refcnt就是作为引用计数，
>当对象被引用时，引用计数+1，当被引用的对象删除时，引用计数-1，当引用计数0，
>该对象的生命周期就结束了。

> 引用计算会产生循环引用的情况，标记-清除[https://zhuanlan.zhihu.com/p/83251959]
>标记：遍历多有的对象，如果还有对象引用它，也就是可达的，那么该对象被标记为可达。
>清除：再次遍历所有的对象，如果发现某个对象没有被标记为可达，那么就被清除。

>分代回收：对象存在的时间越长，越不可能是垃圾。当被分配的对象和释放的对象的差值到达一定比例的时候
>触发gc扫描，如果gc扫描的时间，如果被引用的次数大于某一个阈值，则被保留下一代。
>
2. python 多继承，两个父类有同名方法怎么办？
> 按照从左到右的顺序继承，C(A,B) super().xx，继承的为A
>supre(A, self).XX 需要知道B的左边是A，就可以继承B了。


3. 数组， 元组和列表的区别
> list是python内置的数据类型，python本身是没有数据类型的
> 可以使用numpy库中的array。list中可以存储类型不一样的数据。
>
>list长度和元素都可以修改，tuple长度和元素不可以修改
>

4. Python 中 append 和 extend 的区别？
> append在列表的尾端添加一个元素，可以是任意类型。
>extend，在列表的尾部添加一个可迭代的序列，将值依次添加到列表尾部
>

5. python 中 range＆xrange 有什么区别？
> range生成一个列表
> xrange生成一个生成器
>python3.x取消内建的xrange, range的返回是一个可迭代的对象（iter），
>可迭代对象包含迭代器（next），生成器是一种特殊的迭代器
>
>
6. 说一下 python 迭代器和生成器？
> 实现了yield 关键字的被成为生成器，生成器是惰性返回的，不会一次将
>所有的值读到内存中，在for循环或者使用next()按次读取。
>
>
7. yield 关键字作用
> 被yield关键字装饰的是生成器， 类似return的关键字，但是yield是惰性的
>不会一次将满足条件的值返回。
>
>
8. python 装饰器是什么？
> [https://zhuanlan.zhihu.com/p/35368701]
> 装饰一个函数，让函数拥有原本没有的功能。
> 引用装饰器会便于开发，便于代码的如用
``` 语法糖
def addfunc(func): 
  def decorator(*args, **kwargs):  
      print('有火眼金睛了') 
      return func(*args, **kwargs) 
  return decorator
```
>
>
>
>
>
>
>
>
>
>
8. Python 中==和 is 的区别
> is 用于判断两个变量内存中的地址是否相等，也就是引用的对象是否为同一个
> == 用于判断两个变量的值是否一样
>
9. 区分下 break，continue 和 pass？
> pass 跳过当前，继续执行下面的代码
> continue 跳过当前循环，继续下一个循环
> break 跳出当前的循环

10. Python 中的局部变量和全局变量是什么？
> [https://zhuanlan.zhihu.com/p/111284408]
> 局部变量在只能在函数内部使用的变量
> 全局变量定义在函数外的变量
>> L(local)  E(Enclosing) G(Global) B(build-in) l-e-g-b
> 优先级：先在函数内部寻找变量，然后在闭包外的函数中寻找，再到全局变量
> 如果再函数内部使用的全局变量需要修改时，需要使用global申明。
>否则会抛出 unboundlocalerror的异常。
>
>
>
>
11. pandas怎么读取大型文件
> chunksize分块读取大型文件
>
>
>
>
>
>

python 多线程/多进程/协程
> 进程是CPU资源分配的基本单位，线程是独立运行和独立调度的基本单位
>CPU上真正运行的是线程。
>进程拥有自己的资源空间，一个进程包含若干个线程，线程和CPU资源分配无关
>多个线程共享同一进程内的资源
>线程的调度与切换比进程快的多。
>CPU密集型代码使用多进程。IO密集使用多线程
> 协程是比线程更轻量级的存在，不受CPU资源的管理，由程序代码管理。
>比如yield是由协程实现的。
>
乐观锁/悲观锁 
>乐观锁：相信别人不会修改数据
>悲观锁：不相信别人不会更改数据。 每次查询、修改数据操作之前就会上锁
>
>
>
>
>
>
>
>
>
>
>
>
>
>


Python 深浅拷贝
> [https://zhuanlan.zhihu.com/p/54011712]
> 赋值：地址相同，对象会随着原列表一起变化
> 浅拷贝：地址不同，当浅层元素不会随着原列表的变化而变化，内层添加元素时，才会发生变化
>  也就是说-列表不是原列表，但是里面的元素还是原来对象的引用
> 深拷贝：地址不同，不会随着原列表变化
> 不可变对象没有拷贝的概念，即使深拷贝也指向同一个对象





